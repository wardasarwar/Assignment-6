# -*- coding: utf-8 -*-
"""OOP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JpnILEjwnsRlS35C35dLcRvS9vECK5MI

# ‚úÖ 1. Using self
Assignment:
Create a class Student with attributes name and marks. Use the self keyword to initialize these values via a constructor. Add a method display() that prints student details.
"""

# 1. Using `self`

class Student:
    def __init__(self, name, marks):
        self.name = name         # 'self' refers to the instance of the class
        self.marks = marks

    def display(self):
        print(f"Name: {self.name}, Marks: {self.marks}")


# Example usage:
student1 = Student("hasseb", 92)
student1.display()

class Student:
    def __init__(self, name, marks):
        self.name = name
        self.marks = marks

ameer = Student("Ameer", 92)
ali = Student("Ali", 87)

"""# ‚úÖ 2. Using cls
üìò Assignment:
Create a class Counter that keeps track of how many objects have been created.
Use a class variable and a class method with cls to manage and display the count.
"""

# 2. Using `cls`

class Counter:
    count = 0  # class variable

    def __init__(self):
        Counter.count += 1  # jab bhi object banega, count barh jaega

    @classmethod
    def display_count(cls):
        print(f"Total objects created: {cls.count}")


# Example usage:
obj1 = Counter()
obj2 = Counter()
obj3 = Counter()

Counter.display_count()

"""# ‚úÖ 3. Public Variables and Methods
üìò Assignment:
Create a class Car with a public variable brand and a public method start().
Instantiate the class and access both from outside the class.


"""

# 3. Public Variables and Methods

class Car:
    def __init__(self, brand):
        self.brand = brand  # public variable

    def start(self):  # public method
        print(f"{self.brand} is starting...")


# Example usage:
my_car = Car("Toyota")         # object banaya
print(my_car.brand)            # public variable access kiya
my_car.start()                 # public method call kiya

"""# ‚úÖ 4. Class Variables and Class Methods
üìò Assignment:
Create a class Bank with a class variable bank_name.
Add a class method change_bank_name(cls, name) that allows changing the bank name.
Show that it affects all instances.
"""

class Bank:
    bank_name = "Default Bank"  # shared by all

    @classmethod
    def change_bank_name(cls, name):
        cls.bank_name = name


# Making accounts
acc1 = Bank()
acc2 = Bank()

# Before change
print(acc1.bank_name)
print(acc2.bank_name)

# Changing bank name for all
Bank.change_bank_name("UBL Bank")

# After change
print(acc1.bank_name)
print(acc2.bank_name)

"""# ‚úÖ 5. Static Variables and Static Methods
üìò Assignment:
Create a class MathUtils with a static method add(a, b) that returns the sum.
No class or instance variables should be used.
"""

class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b
# Call static method directly using class
result = MathUtils.add(5, 7)
print("Sum is:", result)

"""# ‚úÖ 6. Constructors and Destructors
üìò Assignment:
Create a class Logger that prints a message when an object is created (constructor) and another message when it is destroyed (destructor).
"""

class Logger:
    def __init__(self):
        print("Logger object created.")

    def __del__(self):
        print("Logger object destroyed.")
log = Logger()  # Constructor will run here

# Optionally delete manually to force destructor
del log

"""# **‚úÖ 7. Access Modifiers: Public, Protected, and Private**
üìò Assignment:
Create a class Employee with:

a public variable name

a protected variable _salary

a private variable __ssn

Try accessing all three from outside the class and document what happens.
"""

class Employee:
    def __init__(self, name, salary, ssn):
        self.name = name          # public
        self._salary = salary     # protected
        self.__ssn = ssn          # private

emp = Employee("Ameer", 80000, "123-45-6789")

print("Public:", emp.name)           # ‚úÖ Direct access
print("Protected:", emp._salary)     # ‚ö†Ô∏è Possible, but not recommended

# Private variable: will raise error if accessed directly
# print(emp.__ssn)  ‚ùå Error

# Correct way using name mangling:
print("Private:", emp._Employee__ssn)  # ‚úÖ Accessed safely

"""# 8. The super() Function
Assignment:
Create a class Person with a constructor that sets the name. Inherit a class Teacher from it, add a subject field, and use super() to call the base class constructor.
"""

class Person:
    def __init__(self, name):
        self.name = name

class Teacher(Person):
    def __init__(self, name, subject):
        super().__init__(name)  # Call parent constructor
        self.subject = subject

# Example usage
t = Teacher("Ameer", "Math")
print("Name:", t.name)
print("Subject:", t.subject)

"""# 9. Abstract Classes and Methods
Assignment:
Use the abc module to create an abstract class Shape with an abstract method area(). Inherit a class Rectangle that implements area().
"""

from abc import ABC, abstractmethod

# Abstract class Shape
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

# Rectangle class that inherits from Shape
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Example usage
rect = Rectangle(5, 10)
print("Area of Rectangle:", rect.area())

"""# 10. Instance Methods
Assignment:
Create a class Dog with instance variables name and breed. Add an instance method bark() that prints a message including the dog's name.
"""

class Dog:
    def __init__(self, name, breed):
        self.name = name  # instance variable
        self.breed = breed  # instance variable

    def bark(self):
        print(f"{self.name} says Woof!")

# Example usage
dog1 = Dog("Buddy", "Golden Retriever")
dog1.bark()

"""# 11. Class Methods
Assignment:
Create a class Book with a class variable total_books. Add a class method increment_book_count() to increase the count when a new book is added.
"""

class Book:
    total_books = 0  # class variable

    @classmethod
    def increment_book_count(cls):
        cls.total_books += 1  # Increase the count of total books

# Example usage
Book.increment_book_count()  # First book
Book.increment_book_count()  # Second book

print("Total Books:", Book.total_books)  # Output total books

"""# 12. Static Methods
Assignment:
Create a class TemperatureConverter with a static method celsius_to_fahrenheit(c) that returns the Fahrenheit value.
"""

class TemperatureConverter:
    @staticmethod
    def celsius_to_fahrenheit(c):
        return (c * 9/5) + 32  # Formula for converting Celsius to Fahrenheit

# Example usage
celsius = 25
fahrenheit = TemperatureConverter.celsius_to_fahrenheit(celsius)
print(f"{celsius}¬∞C is equal to {fahrenheit}¬∞F")

"""# 13. Composition
Assignment:
Create a class Engine and a class Car. Use composition by passing an Engine object to the Car class during initialization. Access a method of the Engine class via the Car class.
"""

class Engine:
    def start(self):
        return "Engine started"

class Car:
    def __init__(self, engine):
        self.engine = engine  # Engine object passed during Car initialization

    def start_car(self):
        return self.engine.start()  # Accessing Engine's start method via Car

# Example usage
engine = Engine()  # Creating an Engine object
car = Car(engine)  # Passing Engine object to Car
print(car.start_car())  # Access Engine's start method through Car

"""# 14. Aggregation
Assignment:
Create a class Department and a class Employee. Use aggregation by having a Department object store a reference to an Employee object that exists independently of it.
"""

class Employee:
    def __init__(self, name, role):
        self.name = name
        self.role = role

    def display(self):
        return f"Employee: {self.name}, Role: {self.role}"

class Department:
    def __init__(self, dept_name, employee):
        self.dept_name = dept_name
        self.employee = employee  # Aggregation: storing reference to Employee object

    def department_info(self):
        return f"Department: {self.dept_name}, Employee: {self.employee.display()}"

# Example usage
emp = Employee("Ali", "Software Engineer")  # Independent Employee object
dept = Department("IT", emp)  # Department contains reference to Employee object
print(dept.department_info())

"""# 15. Method Resolution Order (MRO) and Diamond Inheritance
Assignment:
Create four classes:

A with a method show(),

B and C that inherit from A and override show(),

D that inherits from both B and C.

Create an object of D and call show() to observe MRO.
"""

class A:
    def show(self):
        print("Method in A")

class B(A):
    def show(self):
        print("Method in B")

class C(A):
    def show(self):
        print("Method in C")

class D(B, C):  # Inheriting from both B and C
    pass

# Example usage
obj = D()
obj.show()  # Observing MRO

"""# 16. Function Decorators
Assignment:
Write a decorator function log_function_call that prints "Function is being called" before a function executes. Apply it to a function say_hello().
"""

def log_function_call(func):
    # This is the decorator function
    def wrapper():
        print("Function is being called")  # Print before function call
        func()  # Call the original function
    return wrapper

@log_function_call  # Apply the decorator
def say_hello():
    print("Hello, world!")

# Example usage
say_hello()

"""# 17. Class Decorators
Assignment:
Create a class decorator add_greeting that modifies a class to add a greet() method returning "Hello from Decorator!". Apply it to a class Person.
"""

def add_greeting(cls):
    # This is the class decorator
    def greet(self):
        return "Hello from Decorator!"

    cls.greet = greet  # Adding greet method to the class
    return cls  # Return the modified class

@add_greeting  # Apply the class decorator
class Person:
    def __init__(self, name):
        self.name = name

# Example usage
p = Person("Ameer")
print(p.greet())  # Calling the greet method added by the decorator

"""# 18. Property Decorators: @property, @setter, and @deleter
Assignment:
Create a class Product with a private attribute _price. Use @property to get the price, @price.setter to update it, and @price.deleter to delete it.
"""

class Product:
    def __init__(self, price):
        self._price = price  # Private attribute

    @property
    def price(self):
        return self._price  # Getter: Access price

    @price.setter
    def price(self, value):
        if value < 0:
            print("Price cannot be negative!")
        else:
            self._price = value  # Setter: Update price

    @price.deleter
    def price(self):
        print("Price is being deleted")
        del self._price  # Deleter: Delete price


# Example usage
p = Product(100)
print(p.price)  # Accessing the price using @property

p.price = 150  # Setting a new price using @price.setter
print(p.price)

del p.price  # Deleting the price using @price.deleter

"""# 19. callable() and __call__()
Assignment:
Create a class Multiplier with an __init__() to set a factor. Define a __call__() method that multiplies an input by the factor. Test it with callable() and by calling the object like a function.


"""

class Multiplier:
    def __init__(self, factor):
        self.factor = factor  # Factor to multiply

    def __call__(self, x):
        return x * self.factor  # Multiply input by factor

# Example usage
m = Multiplier(5)  # Set factor to 5

# Using callable() to check if the object is callable
print(callable(m))  # Should return True

# Calling the object like a function
result = m(10)  # Multiplies 10 by factor 5
print(result)  # Output: 50

"""# 20. Creating a Custom Exception
Assignment:
Create a custom exception InvalidAgeError. Write a function check_age(age) that raises this exception if age < 18. Handle it with try...except.
"""

# Step 1: Create a custom exception
class InvalidAgeError(Exception):
    pass  # Custom error without extra logic

# Step 2: Function to check age
def check_age(age):
    if age < 18:
        raise InvalidAgeError("Age must be 18 or older.")

# Step 3: Try-except to handle exception
try:
    check_age(16)  # Trying with age < 18
except InvalidAgeError as e:
    print("Custom Exception Caught:", e)

"""# 21. Make a Custom Class Iterable
Assignment:
Create a class Countdown that takes a start number. Implement __iter__() and __next__() to make the object iterable in a for-loop, counting down to 0.
"""

class Countdown:
    def __init__(self, start):
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.current < 0:
            raise StopIteration  # No more items
        value = self.current
        self.current -= 1
        return value

# Example usage
for num in Countdown(5):
    print(num)
